% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/specdiv_functions.R
\name{count_noNA}
\alias{count_noNA}
\title{#' Short PCA for matrix-----
#'
#' @param x numeric. matrix on which PCA should be applied
#' @param scaling numeric.
#' @param p numeric. cumulated proportion of variance explained by the components provided as outputs
#'
#' @return out list. list of PCA outputs
#' @export}
\usage{
count_noNA(x)
}
\arguments{
\item{x}{dataframe. includes a list of values}
}
\value{
dataframe number of non-NA values
}
\description{
pca_mat <- function(x, scaling = c(1, 2), p = 0.99) {
  Y <- scale(x, center = TRUE, scale = FALSE)
  n <- nrow(Y)
  Y.svd = svd(Y)
  values = (1/(n - 1)) * Y.svd$d^2
  epsilon = sqrt(.Machine$double.eps)
  k <- base::sum(values > epsilon)
  values <- values[1:k]
  prop <- values / base::sum(values)
  cumprop = cumsum(prop)
  if (p < cumprop[1]) which.values <- c(1, 2) else which.values <- which(cumprop < p)
  values.sel <- values[c(which.values, length(which.values) + 1)]
  n.pcs <- length(values.sel)
  U <- as.matrix(Y.svd$v[, 1:n.pcs])
  if (scaling == 1) {
    obj <- Y %*% U
    descript <- U
  }
  else {
    obj <- sqrt(n - 1) * as.matrix(Y.svd$u[, 1:n.pcs])
    descript <- U %*% diag(values.sel^(0.5))
  }
  colnames(obj) <- paste0('PC', 1:n.pcs)
  colnames(descript) <- paste0('PC', 1:n.pcs)
  rownames(descript) <- colnames(x)
  prop.sel <- prop[1:n.pcs]; names(prop.sel) <- colnames(descript)
  cumprop.sel <- cumprop[1:n.pcs]; names(cumprop.sel) <- colnames(descript)
  out <- list(obj = obj, descript = descript, prop = prop.sel, cumprop = cumprop.sel)
  return(out)
}
#' PCA for image cube -----
#'
#' @param cube numeric. matrix on which PCA should be applied
#' @param scaling numeric.
#' @param p numeric. cumulated proportion of variance explained by the components provided as outputs
#'
#' @return out list. list of PCA outputs
#' @export
pca <- function(cube, scaling = c(1, 2), p = 0.99) {
  require(tidyverse)
  require(raster)
  require(sp)
  points <- rasterToPoints(cube, spatial = F)
  xy <- points[, 1:2]
  pixels <- points[, 3:ncol(points)]
  Y <- scale(pixels, center = TRUE, scale = FALSE)
  n <- nrow(Y)
  Y.svd = svd(Y)
  values = (1/(n - 1)) * Y.svd$d^2
  epsilon = sqrt(.Machine$double.eps)
  k <- base::sum(values > epsilon)
  values <- values[1:k]
  prop <- values / base::sum(values)
  cumprop = cumsum(prop)
  if (p < cumprop[1]) which.values <- c(1, 2) else which.values <- which(cumprop < p)
  values.sel <- values[c(which.values, length(which.values) + 1)]
  n.pcs <- length(values.sel)
  U <- as.matrix(Y.svd$v[, 1:n.pcs])
  if (scaling == 1) {
    obj <- Y %*% U
    descript <- U
  }
  else {
    obj <- sqrt(n - 1) * as.matrix(Y.svd$u[, 1:n.pcs])
    descript <- U %*% diag(values.sel^(0.5))
  }
  colnames(obj) <- paste0('PC', 1:n.pcs)
  colnames(descript) <- paste0('PC', 1:n.pcs)
  rownames(descript) <- colnames(pixels)
  points_df <- SpatialPixelsDataFrame(xy, as.data.frame(obj), proj4string = CRS(proj4string(cube) ))
  prop.sel <- prop[1:n.pcs]; names(prop.sel) <- colnames(descript)
  cumprop.sel <- cumprop[1:n.pcs]; names(cumprop.sel) <- colnames(descript)
  cube_pc <- brick(points_df)
  out <- list(cube_pc = cube_pc, band_contrib = descript, prop = prop.sel, cumprop = cumprop.sel)
  return(out)
}
Count non-NA rows
}
